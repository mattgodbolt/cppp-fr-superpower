<!doctype html>
<html lang="en-GB">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title></title>

    <link rel="stylesheet" href="reveal.js/dist/reset.css">
    <link rel="stylesheet" href="reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="reveal.js/dist/theme/moon.css">

    <link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css">
    <style>
        div.col2 {
            display: flex;
        }

        div.col2 > div {
            flex: 1;
        }

        table.galaxy {
            background: white;
            border: none;
            color: black;
            border-collapse: collapse;
            padding: 0;
        }

        table.galaxy tr {
            padding: 0;
            margin: 0;
            border: none;
        }

        table.galaxy td {
            padding: 0;
            margin: 0;
            border: none;
        }

        table.galaxy td.word {
            padding: 10px;
            vertical-align: middle;
        }

        table.galaxy img {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>

<div class="reveal">
    <div class="slides">
        <section>
            <!-- INTRO -->
            <section>
                <h2>C++'s Superpower</h2>
                <h4>Matt Godbolt &mdash; <a href="https://twitter.com/mattgodbolt">@mattgodbolt</a></h4>
                <h6><a href="https://cppp.fr">cppp.fr</a> December 2021</h6>
            </section>
            <section>
                Before we talk about super powers?
                What's the worst thing about C++?
            </section>
            <section>
                <h2>What is a superpower?</h2>
                <dl class="fragment">
                    <dt>Superpower</dt>
                    <dd>A state with a dominant position characterized by its extensive ability to exert influence or
                        project power on a global scale.
                    </dd>
                </dl>
                <aside class="notes">
                    A superpower is something which nobody else possesses.
                </aside>
            </section>
            <section>
                <h2>C++'s Superpower</h2>
                <div>TODO: IMAGE OF SUPERMAN LOGO WITH C++ INSTEAD</div>
            </section>
            <section>
                <h2>What could it be?</h2>
                <ul>
                    <li>Multi-paradigm</li>
                    <li>TODO more</li>
                </ul>
            </section>
            <section>
                <h2>What could it be?</h2>
                <ul>
                    <li>Wrong defaults</li>
                    <li>Legacy</li>
                    <li>Undefined behaviour</li>
                    <li>TODO more</li>
                </ul>
            </section>
            <section>
                <h2>Backwards compatibility!</h2>
            </section>
            <section>
                Maybe for the conclusion slides?
                even talk about how Compiler Explorer came about partially as moving forward incrementally wilhe keeping
                backwards compat with a trading system?
            </section>
        </section>

        <section>
            <!-- back story -->
            <section>
                <h2>Backstory</h2>
            </section>
            <section>
                <h2>History</h2>
                <ul>
                    <li>80s to early 90s - 6502 and ARM assembly</li>
                    <li>1994 discovered C</li>
                    <li>1997 started writing C++</li>
                    <li>...</li>
                    <li>2020 rediscovered 1995-era code...</li>
                </ul>
            </section>
            <section>
                <h2>What is a MUD?</h2>
                <ul>
                    <li>Dungeons &amp; Dragons</li>
                    <li>Multiplayer</li>
                    <li>Raw TCP clients</li>
                </ul>
            </section>
            <section>
                <h2>What is a MUD?</h2>
                <div>A giant text processor</div>
                taking user input! classic c code strong suit...er..
            </section>
            <section>
                <h2>The goal</h2>
                <ul>
                    <li>Take 90s-era C</li>
                    <li>Port to modern C++17 (C++20?)</li>
                    <li>Incrementally!</li>
                </ul>
            </section>
        </section>

        <section>
            <!-- The beginning -->
            <section>
                <h2>Groundwork</h2>
                <ul>
                    <li><code>git</code></li>
                    <li><code>cmake</code></li>
                    <li><code>-Wall -Wextra</code></li>
                    <li><code>clang-format</code></li>
                    <li><code>-fsanitize=...</code></li>
                    <li><a href="https://conan.io">conan</a></li>
                </ul>
            </section>
            <section>
                <h2>The most important thing</h2>
                <ul>
                    <li>Manual tests (to begin with)</li>
                    <li>Tests! Catch2</li>
                </ul>
            </section>
            <section>
                <h2>The C++ification</h2>
                <pre><code data-trim>
                $ rename .c .cpp *.c
                $ rename .h .hpp *.h
                </code></pre>
            </section>
            <section>
                <h2>overlap</h2>
                <div>TODO venn diagram of D&amp;D vs C++, and string formatting showing class and template</div>
            </section>
        </section>

        <section>
            <!-- incremental updates -->
            <section data-auto-animate>
                <h2>How to improve?</h2>
                <pre data-auto-animate-id="code"><code data-trim data-noescape class="cpp">
struct area_data {
  struct area_data *next;
  char *name;
  sh_int age;
  sh_int nplayer;
  bool empty;
  char *areaname;
  char *filename;
  int lvnum;
  int uvnum;
  int vnum;
};

typedef struct area_data AREA_DATA;
AREA_DATA *areas;</code></pre>
            </section>
            <section data-auto-animate="">
                <h2>How to improve?</h2>
                <div class="col2">
                    <div>
                        <pre data-auto-animate-id="code"><code data-trim data-noescape class="cpp">
struct area_data {
  struct area_data *next;<span class="fragment" data-fragment-index="1">// hand-rolled</span>
  char *name;       <span class="fragment" data-fragment-index="2">// const</span><span class="fragment"
                                                                                        data-fragment-index="3">, c-style</span>
  sh_int age;
  sh_int nplayer;
  bool empty;
  char *areaname;   <span class="fragment" data-fragment-index="2">// const</span><span class="fragment"
                                                                                        data-fragment-index="3">, c-style</span>
  char *filename;   <span class="fragment" data-fragment-index="2">// const</span><span class="fragment"
                                                                                        data-fragment-index="3">, c-style</span>
  int lvnum;
  int uvnum;
  int vnum;
};
<span class="fragment" data-fragment-index="4">// Unnecessary!</span>
typedef struct area_data AREA_DATA;
AREA_DATA *areas;   <span class="fragment" data-fragment-index="5">// Global!</span>
</code></pre>
                    </div>
                    <div>
                        <ul>
                            <li class="fragment" data-fragment-index="1">Hand-rolled linked list</li>
                            <li class="fragment" data-fragment-index="2">Not <code>const</code> correct</li>
                            <li class="fragment" data-fragment-index="3">C-style strings!</li>
                            <li class="fragment" data-fragment-index="4">Unnecessary <code>typedef</code></li>
                            <li class="fragment" data-fragment-index="5">Global!</li>
                            <li class="fragment">Encapsulation, <code>class</code></li>
                        </ul>
                    </div>
                </div>
            </section>
            <section>
                <h2>Simple fix</h2>
                <div class="col2">
                    <div><pre><code data-trim data-noescape class="cpp">
struct area_data {
  struct area_data *next;
  // ...
};
typedef struct area_data AREA_DATA;
                    </code></pre>
                    </div>
                    <div><pre><code data-trim data-noescape class="cpp">
struct AREA_DATA {
  AREA_DATA *next;
  // ...
};
                    </code></pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>Changing an element</h2>
                <div class="col2">
                    <div><pre><code data-trim data-noescape class="cpp">
struct AREA_DATA {
  AREA_DATA *next;
  char *name;         // <---
  char *areaname;
  char *filename;
  // ...
};
                </code></pre>
                    </div>
                    <div><pre><code data-trim data-noescape class="cpp">
struct AREA_DATA {
  AREA_DATA *next;
  std::string name;   // <---
  char *areaname;
  char *filename;
  // ...
};
                </code></pre>
                    </div>
            </section>
            <section>
                <h2>Changing an element</h2>
                <h5>Compile errors...</h5>
                <ul>
                    <li>Assignment</li>
                    <li><code>.c_str()</code></li>
                    <li><code>snprintf</code> warnings...</li>
                    <li><code>__attribute__((format(printf, 2, 3)</code></li>
                    <li>Sanitizer!</li>
                    <li>Testing is just run the app</li>
                </ul>
            </section>
            <section>
                <h2>So now...</h2>
                <div>
                    <pre><code data-trim data-noescape class="cpp">
struct AREA_DATA {
  AREA_DATA *next;
  std::string name;
  std::string areaname;
  std::string filename;
  // ...
};
                    </code></pre>
                </div>
            </section>
            <section>
                <h2>Replace linked-list with STL</h2>
                pointer stability, vector of unique ptr
            </section>
            <section>
                <h2>So now...</h2>
                <div>
                    <pre><code data-trim data-noescape class="cpp">
struct AREA_DATA {
  std::string name;
  std::string areaname;
  std::string filename;
  // ...
};

std::vector&lt;std::unique_ptr&lt;AREA_DATA&gt;&gt; areas; // still global
                    </code></pre>
                </div>
            </section>
            <section>
                <h2>Class-i-fy</h2>
                <ul>
                    <li>struct->class but public:</li>
                    <li>move each inside, build test</li>
                    <li>accessor functions</li>
                </ul>
            </section>
            <section>
                <h2>Class-i-fy</h2>
                <ul>
                    <li>Start moving functionality</li>
                    <li>AREA *load_area -> Area::parse</li>
                    <li>Start writing tests!</li>
                </ul>
            </section>
            <section>
                <h2>Class-i-fied</h2>
                <div class="col2">
                    <div><pre><code data-trim data-noescape class="cpp">
class Area {
  std::string description_;
  ush_int num_players_{};
  bool empty_since_last_reset_{};
  int min_level_{0};
  int max_level_{MAX_LEVEL};
  std::string short_name_;

  Area() = default;
  void reset();
                </code></pre>
                    </div>
                    <div><pre><code data-trim data-noescape class="cpp">
public:
  static Area parse(
    FILE *fp,
    std::string filename);

  void player_entered();
  void player_left();
  void update();

  [[nodiscard]]
  const auto &short_name() const {
    return short_name_;
  }
  // etc...
};
                </code></pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>Test</h2>
                <pre><code data-trim data-noescape class="cpp">
TEST_CASE("area loading") {
  test::MemFile fp(R"(ignored~
Short name~
{ 1 50} TheMoog Some kind of area~
6200 6399
)");
  auto area = Area::parse(fp.file(), "bob");
  CHECK(area.filename() == "bob");
  CHECK(area.short_name() == "Short name");
  CHECK(area.description() == "{ 1 50} TheMoog Some kind of area");
  CHECK(area.min_level() == 1);
  CHECK(area.max_level() == 50);
}
                </code></pre>
            </section>
        </section>

        <section>
            <!-- proto range goodness -->
            <section>
                <h2>Ranges</h2>
                <pre><code data-trim data-noescape class="cpp">
                void Char::yell(std::string_view exclamation) const {
                  act("|WYou yell '$t|W'|w", this, exclamation, nullptr, To::Char);

                  for (auto &victim : descriptors().all_but(*this)
                      | DescriptorFilter::same_area(*this)
                      | DescriptorFilter::to_character()
                    ) {
                    act("|W$n yells '$t|W'|w", this, exclamation, &victim, To::Vict);
                  }
                }
                </code></pre>
            </section>
        </section>

        <section>
            <!-- range goodness -->
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
char *capitalize(const char *str) {
  static char strcap[MAX_STRING_LENGTH];
  int i;

  for (i = 0; str[i] != '\0'; i++)
    strcap[i] = LOWER(str[i]);
  strcap[i] = '\0';
  strcap[0] = UPPER(strcap[0]);
  return strcap;
}
                </code></pre>
            </section>
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
SECTION("capitalize") {
  CHECK(capitalize("a monkey") == "A monkey"s);
  CHECK(capitalize("A MONKEY") == "A monkey"s);
  CHECK(capitalize("a MonkeY") == "A monkey"s);
  CHECK(capitalize("") == ""s);
  CHECK(capitalize("a") == "A"s);
  CHECK(capitalize("A") == "A"s);
}
                </code></pre>
            </section>
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
std::string capitalize(const char *str) {
  std::string result;
  result.resize(strlen(str));
  for (int i = 0; i < strlen(str); i++)
    result[i] = std::tolower(str[i]);
  result[0] = std::toupper(result[0]);  /// BUG!
  return result;
}
                </code></pre>
            </section>
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
std::string capitalize(const char *str) {
  std::string result;
  std::transform(
    str, str + strlen(str), std::back_inserter(result),
    [](char c) -> char { return std::tolower(c); } );
  if (!result.empty())
    result[0] = std::toupper(result[0]);
  return result;
}
                </code></pre>
                <!-- https://godbolt.org/z/Eb3MdTae4 -->
            </section>
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
auto capitalize(std::string_view text) {
  return text
    | ranges::view::enumerate
    | ranges::view::transform([](const auto &pair) -> char {
      return pair.first == 0 ? std::toupper(pair.second) : std::tolower(pair.second);
    })| ranges::to&lt;std::string&gt;;
}
                </code></pre>
            </section>
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
auto capitalize(std::string_view text) {
  return ranges::view::concat(
    // NB not std::toupper
    text | ranges::view::take(1) | ranges::view::transform(toupper),
    text | ranges::view::drop(1) | ranges::view::transform(tolower)
  ) | ranges::to&lt;std::string&gt;
}
                </code></pre>
                <!-- https://godbolt.org/z/eKMsvoxnb -->
            </section>
            <section>
                <h2>String manipulation</h2>
                <ul>
                    <li>to uppercase/lowercase</li>
                    <li>whitespace trimming</li>
                    <li>case insensitive matches</li>
                    <li>prefixes/suffixes</li>
                    <li>parsing</li>
                </ul>
            </section>
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
bool matches_inside(const char *astr, const char *bstr) {
    char c0;
    if ((c0 = LOWER(astr[0])) == '\0')
        return true;

    int sstr1 = strlen(astr);
    int sstr2 = strlen(bstr);

    for (int ichar = 0; ichar <= sstr2 - sstr1; ichar++) {
        if (c0 == LOWER(bstr[ichar]) && has_prefix(astr, bstr + ichar))
            return true;
    }
    return false;
}
                </code></pre>
            </section>
            <section>
                <h2>String manipulation</h2>
                <pre><code data-trim data-noescape class="cpp">
bool matches_inside(std::string_view needle, std::string_view haystack) {
  auto needle_low = needle | ranges::views::transform(tolower);
  auto haystack_low = haystack | ranges::views::transform(tolower);
  return !ranges::search(haystack_low, needle_low).empty();
}
                </code></pre>
            </section>
            <section>
                <ul>
                    <li>string manipulation functions</li>
                    <li>show evolution of initial_caps_only (also code gen!)
                        - original
                        - mutable range
                        - (not checked in)
                        <pre><code>std::string initial_caps_only(std::string_view text) {
    return text | ranges::view::enumerate | ranges::view::transform([](const auto &pair) {
               return pair.first == 0 ? toupper(pair.second) : tolower(pair.second);
           })
           | ranges::to&lt;std::string&gt;;
}</code></pre>
                        - final
                        <pre><code>std::string initial_caps_only(std::string_view text) {
    return ranges::view::concat(text | ranges::view::take(1) | ranges::view::transform(toupper),
                                text | ranges::view::drop(1) | ranges::view::transform(tolower))
           | ranges::to&lt;std::string&gt;;
}</code></pre>
                    </li>
                    <li>Show joyous matches_inside implementation</li>
                </ul>
            </section>
            <section>std::array? std::all_of etc? std::fill</section>
        </section>

        <section>
            <section>
                <h2>String formatting</h2>
                <pre><code data-noescape, data-trim class="c++">
char buf[MAX_STRING_LENGTH];
sprintf(buf, "Your gain is: %d/%d hp, %d/%d m, %d/%d mv %d/%d prac.\n",
  add_hp, ch->max_hit, add_mana, ch->max_mana,
  add_move, ch->max_move, add_prac, ch->practice);
send_to_player(ch, buf);
</code></pre>
            </section>
            <section>
                <h2>String formatting</h2>
                <pre><code data-noescape, data-trim class="c++">
char buf[MAX_STRING_LENGTH];
snprintf(buf, sizeof(buf),
  "Your gain is: %d/%d hp, %d/%d m, %d/%d mv %d/%d prac.\n",
  add_hp, ch->max_hit, add_mana, ch->max_mana,
  add_move, ch->max_move, add_prac, ch->practice);
send_to_player(ch, buf);
</code></pre>
            </section>
            <section>
                <h2>String formatting</h2>
                <pre><code data-noescape, data-trim class="c++">
extern void send_to_player(CHAR *ch, const char *fmt, ...);

send_to_player(ch,
  "Your gain is: %d/%d hp, %d/%d m, %d/%d mv %d/%d prac.\n",
  add_hp, ch->max_hit, add_mana, ch->max_mana,
  add_move, ch->max_move, add_prac, ch->practice);
</code></pre>
            </section>
            <section>
                <h2>String formatting</h2>
                <pre><code data-noescape, data-trim class="c++">
extern void send_to_player(CHAR *ch, const char *fmt, ...)
    __attribute__((format(printf, 2, 3)));

send_to_player(ch,
  "Your gain is: %d/%d hp, %d/%d m, %d/%d mv %d/%d prac.\n",
  add_hp, ch->max_hit, add_mana, ch->max_mana,
  add_move, ch->max_move, add_prac, ch->practice);
</code></pre>
            </section>
            <section>
                <h2>String formatting</h2>
                <pre><code data-noescape, data-trim class="c++">
send_to_player(ch,
  "Your gain is: {}/{} hp, {}/{} m, {}/{} mv {}/{} prac.",
  add_hp, ch->max_hit, add_mana, ch->max_mana,
  add_move, ch->max_move, add_prac, ch->practice);
</code></pre>
            </section>
            <section>
                <h2>String formatting</h2>
                <pre><code data-noescape, data-trim class="c++">
ch->send_line(
  "You can train: {}.",
  fmt::join(
    ranges::views::concat(
      all_stats | ranges::views::filter([&](auto stat) {
        return ch->perm_stat[stat] < get_max_train(ch, stat);
      }) | ranges::views::transform(to_short_string),
      always_trainable
    ),
    " "sv
  )
);

</code></pre>
            </section>
            <section>
                <h2>String formatting</h2>
                <table class="galaxy">
                    <tr class="fragment">
                        <td class="word"><code>sprintf()</code></code></td>
                        <td><img src="images/galaxy1.jpeg" alt="galaxy 1"></td>
                    </tr>
                    <tr class="fragment">
                        <td class="word"><code>snprintf()</code></td>
                        <td><img src="images/galaxy2.jpeg" alt="galaxy 2"></td>
                    </tr>
                    <tr class="fragment">
                        <td class="word"><code>__attribute__((format(printf,2,3)))</code></td>
                        <td><img src="images/galaxy3.jpeg" alt="galaxy 3"></td>
                    </tr>
                    <tr class="fragment">
                        <td class="word"><code>fmt::format()</code></td>
                        <td><img src="images/galaxy4.jpeg" alt="galaxy 4"></td>
                    </tr>
                </table>
            </section>
        </section>

        <section>
            Strong types
        </section>

        <section>
            Bit fields?
        </section>

        <section>
            interim solutions
            naked function -> std::function<>
            overloads; lambdas to make transition easier
            incremental update!
            ArgParser <->
            overloads!
        </section>

        <section>
            <h3>Conclusion</h3>
            <aside class="notes">
                <ul>
                    <li>want people to realise that some things in C++ are that way because of back compat</li>
                    <li>while often annoying backwards compat lets folks do this!</li>
                    <li>not so important for some never-used code like xania, but</li>
                </ul>
            </aside>
        </section>
    </div>
</div>

<script src="reveal.js/dist/reveal.js"></script>
<script src="reveal.js/plugin/notes/notes.js"></script>
<script src="reveal.js/plugin/markdown/markdown.js"></script>
<script src="reveal.js/plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        width: 1200,
        height: 700,
        hash: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
